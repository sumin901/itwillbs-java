package generic;

import java.util.ArrayList;
import java.util.List;

public class Test {

	public static void main(String[] args) {
		// Person 클래스 인스턴스 2개 생성 후 참조변수 출력
		Person p1 = new Person("soomin", 20);
		Person p2 = new Person("minsoo", 29);
		System.out.println(p1);
		System.out.println(p2);
		System.out.println("=====================================");
		
		// Person 객체 여러 개를 하나의 객체에 저장하여 관리하는 경우
		// 1. Object[] 배열 또는 Person[] 배열을 통해 관리
		// => 생성된 배열의 크기가 불변이므로 추가적인 객체 저장 불가
		// => Object 타입으로 업캐스팅된 객체는 다시 다운캐스팅 후 사용
		//    + 다운 캐스팅 전 instanceof 연산자 사용해 판별하는 과정이 필요함
		
		// Object[] 배열에 p1, p2 대입
		Object[] objArr = {p1, p2}; // Person -> Object 업캐스팅 되어 관리
		Person p;
		// 배열 내 객체 모두 출력
		for(int i = 0; i < objArr.length ; i++) {
			// Object[] 배열에 저장된 객체를 직접 다루면 참조 영역이 축소됨
//			System.out.println(objArr[i].name); Person 타입 변수 접근 불가
			
			// 배열 내의 객체를 꺼내서 Person 타입 변수 저장
//			Person p = objArr[i]; >> 다운 캐스팅이 필요함
			// 다운 캐스팅 전 수행 가능한지에 대한 판별
//			if(p instanceof objArr) {
				
			}
		
		List<Person> list2 = new ArrayList<Person>();
		list2.add(p1);
		list2.add(p2);
		list2.add(new Person("somin", 23));
		
		for(Person p : list2) {
			
		}
		
		
		}
		
		/*
		 * 2. Collection API(ex_ ArrayList...) 를 활용해 Person 객체 여러 개를 관리
		 * => 배열의 단점이 크기 불변을 해결, 배열에 추가가 자유로워짐
		 * 
		 * 1) 제네릭을 사용하지 않을 경우
		 * 
		 * - 파라미터 또는 리턴타입의 데이터 타입이 Object 타입이 되어 다양한 객체를 저장 가능하게 됨
		 * 
		 * 
		 * 
		 */
	
		
		
		
		

	}


