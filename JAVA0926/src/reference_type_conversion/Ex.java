package reference_type_conversion;

public class Ex {

	public static void main(String[] args) {
		/*
		 * 			레퍼런스 형변환
		 * 
		 * 어떤 객체(인스턴스)를 다른 타입으로 변환하는 것
		 * 참조형 데이터 타입간의 변환
		 * ( 반드시 상속 관계가 전제되야함 ) << 상속 관계가 아닌 타입간의 형변환은 불가능 
		 * ex) 슈퍼클래스 <-> 서브클래스     형변환
		 * 
		 * 1. 묵시적 형변환 (Upcasting)
		 * 2. 명시적 형변환 (Downcasting)
		 * 
		 * 				1. Upcasting
		 * 
		 * 슈퍼클래스 타입 레퍼런스로 서브클래스 인스턴스를 참조하는 것
		 * = 서브클래스의 인스턴스를 슈퍼클래스 타입으로 변환하는 것
		 * = 컴파일러에의해 자동 형변환이 일어난다 
		 * = 묵시적 형변환
		 * 
		 * 참조 가능한 영역이 축소됨
		 * = 슈퍼클래스로부터 상속된 멤버만 접근이 가능해진다
		 * 
		 * 서브클래스 인스턴스 멤버 중 공통 항목을 제외한 나머지에 대한 포기 선언
		 * = 대신 하나의 슈퍼클래스 타입으로 
		 *   여러 서브클래스의 인스턴스를 참조할 수 있다.
		 * 
		 * 
		 * 
		 */

//		Parent p = new Parent();
		
		// Parent 타입 p 참조변수로 접근 가능한 메서드 : 1개
//		p.parentPrn();
//		p.childPrn(); << 서브클래스에서 직접 정의한 메서드는 호출 불가
		Child c = new Child();
		// child 타입 c 참조변수로 접근 가능한 메서드 : 2개
		c.parentPrn(); // 상속받은 메서드
		c.childPrn(); // 자신의 메서드
		
		System.out.println("-------------------------------------");
		// 슈퍼클래스 Parent의 레퍼런스 변수 선언
		Parent p ;
		
		// 슈퍼클래스 타입 변수 p에 서브클래스 타입 Child 인스턴스 참조변수를 대입
		p = c; // << Upcasting, 묵시적 형변환
		// 서브클래스 Child 타입 인스턴스 -> 슈퍼클래스 Parent 타입으로 형변환
		// = 슈퍼클래스 타입 변수 p가 서브클래스 인스턴스 c를 참조한다
		System.out.println("p와 c의 인스턴스가 동일한가? " + (p == c));
		
		p.parentPrn(); // 상속된 메서드 접근 가능
//		p.childPrn(); 서브클래스에서 직접 정의한 메서드 접근불가, 오류
//		* 슈퍼클래스 타입으로 Upcasting후에는 상속된 메서드만 호출가능하다
//		  즉 슈퍼클래스 타입으로 서브 클래스 인스턴스를 참조하게 되면
//		  참조 영역에 대한 축소로 서브클래스 메서드 사용 불가
		System.out.println("-----------------------------------------");
		
		/*
		 * 2. 다운캐스팅(Down Casting)
		 * - 서브클래스의 레퍼런스가 슈퍼클래스의 인스턴스를 참조하는 것
		 *   = 슈퍼클래스의 인스턴스를 서브클래스 타입으로 형변환하는 것
		 * - 참조 가능한 영역이 확대됨
		 * - 자동 형변환이 일어나지 않음 = 명시적(강제) 형변환 필요
		 * - 강제 형변환을 통해 구문 오류가 해결되더라도
		 *   실제 실행 시점에서 오류(실행 오류)가 발생하게 됨
		 *   => 존재하지 않는 영역의 참조 위험성 때문
		 */
		
		
		// 슈퍼클래스 Parent 타입 인스턴스 p2
		Parent p2 = new Parent();
		
		// 슈퍼클래스 Parent 타입 인스턴스 p2 접근 가능 메서드 : 1개
		p2.parentPrn();
		
		// 서브클래스 Child 타입 변수 c2 선언 
		Child c2;
		
		// 서브클래스 타입 변수 c2에 슈퍼클래스 타입 인스턴스 대입
//		c2 = (Child)p2; 
		// 컴파일 오류 : Type mismatch: cannot convert from Parent to Child
		// 슈퍼 -> 서브 Downcasting은 자동 형변환 불가능
		// 명시적 형변환이 필수
		
		// 슈퍼 클래스 타입 인스턴스 p2 앞에 Child 타입을 명시적으로 작성한다
		// 문법적 오류가 해결되더라도 실행 시점에서 논리적 오류가 발생한다
		// >> Child 타입 변수 c2는 접근 가능 메서드 : 2개
//		c2.childPrn(); // 실제 Parent 인스턴스에 존재하지않는 메서드
//		c2.parentPrn();
		// 존재하지 않는 영역에 대한 참조 위험성 때문에 
		// Downcasting이 기본적으로 불가능하다
		
		// 기본적으로 자바는 Downcasting을 허용하지 않는다
		
		System.out.println("====================================");
		
		// Downcasting이 가능한 경우
		// Child 타입의 인스턴스를 Parent 타입 변수 p3에 전달
		Parent p3 = new Child(); // 자동 묵시적 형변환
		// Upcasting에 의해 참조영역이 축소 되므로 접근 가능한 메서드 : 1개
		p3.parentPrn(); // 상속된 공통 메서드
//		p3.childPrn(); // 상속X, 서브클래스에서 직접 정의한 메서드 = 호출 불가
		
		// Upcasting된 Parent타입 p3의 인스턴스를 Child 타입 변수 c3에 전달
		Child c3 = (Child)p3;
		// Downcasting에 의해 참조 영역이 확대되므로 접근 가능 메서드 : 2개
		c3.childPrn(); // 상속X
		c3.parentPrn(); // 상속받은 메서드
		
		/*
		 * 				2. Down Casting
		 * 
		 * - 서브클래스의 레퍼런스가 슈퍼클래스의 인스턴스를 참조하는 것
		 *   = 슈퍼클래스의 인스턴스를 서브클래스 타입으로 형변환하는 것
		 * - 참조 가능한 영역이 확대됨
		 * - 자동 형변환이 일어나지 않음 = 명시적(강제) 형변환 필요
		 * - 강제 형변환을 통해 구문 오류가 해결되더라도
		 *   실제 실행 시점에서 오류(실행 오류)가 발생하게 됨
		 *   => 존재하지 않는 영역의 참조 위험성 때문
		 *   ==========================================================
		 * - 다운 캐스팅 후에도 실행 시 오류가 발생할 수 있으므로
		 *   인스턴스의 클래스 타입과 참조하는 레퍼런스 변수의
		 *   상속 관계를 고려하여 다운캐스팅을 수행해야 한다!
		 *   
		 *   => 결론!
		 *      이전에 이미 업캐스팅 된 인스턴스(레퍼런스)를
		 *      다시 다운캐스팅하는 경우에만 안전하다!
		 *      ( 그 외 다운캐스팅은 인정되지 않는다!)
		 */
		 
		
		
		
		
	}

}

class Parent {
	// 클래스 멤버 : 1개 (자신)
	public void parentPrn() {
		System.out.println("슈퍼클래스 parentPrn()");
	}
}
class Child extends Parent {
	// 클래스 멤버 : 2개 (자신 + 상속)
	public void childPrn() {
		System.out.println("서브클래스 childPrn()");
	}
}